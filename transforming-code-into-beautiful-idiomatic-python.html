<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="zh"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>[译]让你的Python代码优雅又地道 &mdash; 0xFEE1C001</title>
  <meta name="author" content="Light Xue">
  <meta name="description" content="如何写出优雅的、地道、pythonic的的python代码" />

  <link href="/feeds/atom.xml" type="application/atom+xml" rel="alternate"
        title="0xFEE1C001 Atom Feed" />





  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">


    <link href="/favicon.png" rel="icon">

  <link href="/theme/css/main.css" media="screen, projection"
        rel="stylesheet" type="text/css">

  <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
</head>

<body>
  <header role="banner"><hgroup>
  <h1><a href="/">0xFEE1C001</a></h1>
    <h2>Where there is a shell, there is a way</h2>
</hgroup></header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/feeds/atom.xml" rel="subscribe-atom">Atom</a></li>
</ul>


<ul class="main-navigation">
    <li><a href="/">首页</a></li>
    <li><a href="http://tools.lightxue.com">程序员工具</a></li>
</ul></nav>
  <div id="main">
    <div id="content">
<div>
  <article class="hentry" role="article">
<header>
      <h1 class="entry-title">[译]让你的Python代码优雅又地道</h1>
    <p class="meta">
<time datetime="2017-06-18T17:55:00+08:00" pubdate>2017-06-18</time>    </p>
</header>

  <div class="entry-content"><h2>译序</h2>
<blockquote>
<p>如果说优雅也有缺点的话，那就是你需要艰巨的工作才能得到它，需要良好的教育才能欣赏它。</p>
<p>—— Edsger Wybe Dijkstra</p>
</blockquote>


<p>在Python社区文化的浇灌下，演化出了一种独特的代码风格，去指导如何正确地使用Python，这就是常说的pythonic。一般说地道(idiomatic)的python代码，就是指这份代码很pythonic。Python的语法和标准库设计，处处契合着pythonic的思想。而且Python社区十分注重编码风格一的一致性，他们极力推行和处处实践着pythonic。所以经常能看到基于某份代码P vs NP (pythonic vs non-pythonic)的讨论。pythonic的代码简练，明确，优雅，绝大部分时候执行效率高。阅读pythonic的代码能体会到“代码是写给人看的，只是顺便让机器能运行”畅快。</p>
<p>然而什么是pythonic，就像什么是地道的汉语一样，切实存在但标准模糊。<code>import this</code>可以看到Tim Peters提出的Python之禅，它提供了指导思想。许多初学者都看过它，深深赞同它的理念，但是实践起来又无从下手。PEP 8给出的不过是编码规范，对于实践pythonic还远远不够。如果你正被如何写出pythonic的代码而困扰，或许这份笔记能给你帮助。</p>
<p>Raymond Hettinger是Python核心开发者，本文提到的许多特性都是他开发的。同时他也是Python社区热忱的布道师，不遗余力地传授pythonic之道。这篇文章是网友Jeff Paine整理的他在2013年美国的PyCon的<a href="http://pyvideo.org/pycon-us-2013/transforming-code-into-beautiful-idiomatic-pytho.html">演讲</a>的笔记。</p>
<p>术语澄清：本文所说的集合全都指<code>collection</code>，而不是<code>set</code>。</p>
<p>原文链接：https://gist.github.com/JeffPaine/6213790。以下是正文。</p>
<hr>
<p>本文是Raymond Hettinger在2013年美国PyCon演讲的笔记(<a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=OSGv2VnC0go">视频</a>, <a href="https://speakerdeck.com/pyconslides/transforming-code-into-beautiful-idiomatic-python-by-raymond-hettinger-1">幻灯片</a>)。</p>
<p>示例代码和引用的语录都来自Raymond的演讲。这是我按我的理解整理出来的，希望你们理解起来跟我一样顺畅！</p>
<h2>遍历一个范围内的数字</h2>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]:</span>
    <span class="k">print</span> <span class="n">i</span> <span class="o">**</span> <span class="mi">2</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">i</span> <span class="o">**</span> <span class="mi">2</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">i</span> <span class="o">**</span> <span class="mi">2</span>
</pre></div>


<p><code>xrange</code>会返回一个迭代器，用来一次一个值地遍历一个范围。这种方式会比<code>range</code>更省内存。<code>xrange</code>在Python 3中已经改名为<code>range</code>。</p>
<h2>遍历一个集合</h2>
<div class="highlight"><pre><span></span><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;yellow&#39;</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)):</span>
    <span class="k">print</span> <span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">color</span>
</pre></div>


<h2>反向遍历</h2>
<div class="highlight"><pre><span></span><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;yellow&#39;</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">colors</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">color</span>
</pre></div>


<h2>遍历一个集合及其下标</h2>
<div class="highlight"><pre><span></span><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;yellow&#39;</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)):</span>
    <span class="k">print</span> <span class="n">i</span><span class="p">,</span> <span class="s1">&#39;---&gt;&#39;</span><span class="p">,</span> <span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">colors</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">i</span><span class="p">,</span> <span class="s1">&#39;---&gt;&#39;</span><span class="p">,</span> <span class="n">color</span>
</pre></div>


<blockquote>
<p>这种写法效率高，优雅，而且帮你省去亲自创建和自增下标。</p>
<p>当你发现你在操作集合的下标时，你很有可能在做错事。</p>
</blockquote>
<h2>遍历两个集合</h2>
<div class="highlight"><pre><span></span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;raymond&#39;</span><span class="p">,</span> <span class="s1">&#39;rachel&#39;</span><span class="p">,</span> <span class="s1">&#39;matthew&#39;</span><span class="p">]</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;yellow&#39;</span><span class="p">]</span>

<span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;---&gt;&#39;</span><span class="p">,</span> <span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;---&gt;&#39;</span><span class="p">,</span> <span class="n">color</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">izip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">colors</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;---&gt;&#39;</span><span class="p">,</span> <span class="n">color</span>
</pre></div>


<p><code>zip</code>在内存中生成一个新的列表，需要更多的内存。<code>izip</code>比<code>zip</code>效率更高。</p>
<p>注意：在Python 3中，<code>izip</code>改名为<code>zip</code>，并替换了原来的<code>zip</code>成为内置函数。</p>
<h2>有序地遍历</h2>
<div class="highlight"><pre><span></span><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;yellow&#39;</span><span class="p">]</span>

<span class="c1"># 正序</span>
<span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">colors</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">colors</span>

<span class="c1"># 倒序</span>
<span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">colors</span>
</pre></div>


<h2>自定义排序顺序</h2>
<div class="highlight"><pre><span></span><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;yellow&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">compare_length</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">c2</span><span class="p">):</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">c2</span><span class="p">):</span> <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="k">print</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span> <span class="nb">cmp</span><span class="o">=</span><span class="n">compare_length</span><span class="p">)</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="k">print</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
</pre></div>


<p>第一种方法效率低而且写起来很不爽。另外，Python 3已经不支持比较函数了。</p>
<h2>调用一个函数直到遇到标记值</h2>
<div class="highlight"><pre><span></span><span class="n">blocks</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">block</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">block</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="n">blocks</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
</pre></div>


<p><code>iter</code>接受两个参数。第一个是你反复调用的函数，第二个是标记值。</p>
<p>译注：这个例子里不太能看出来方法二的优势，甚至觉得<code>partial</code>让代码可读性更差了。方法二的优势在于<code>iter</code>的返回值是个迭代器，迭代器能用在各种地方，<code>set</code>，<code>sorted</code>，<code>min</code>，<code>max</code>，<code>heapq</code>，<code>sum</code>……</p>
<h2>在循环内识别多个退出点</h2>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">i</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">i</span>
</pre></div>


<p><code>for</code>执行完所有的循环后就会执行<code>else</code>。</p>
<p>译注：刚了解<code>for-else</code>语法时会困惑，什么情况下会执行到<code>else</code>里。有两种方法去理解<code>else</code>。传统的方法是把<code>for</code>看作<code>if</code>，当<code>for</code>后面的条件为<code>False</code>时执行<code>else</code>。其实条件为<code>False</code>时，就是<code>for</code>循环没被<code>break</code>出去，把所有循环都跑完的时候。所以另一种方法就是把<code>else</code>记成<code>nobreak</code>，当<code>for</code>没有被<code>break</code>，那么循环结束时会进入到<code>else</code>。</p>
<h2>遍历字典的key</h2>
<div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;matthew&#39;</span><span class="p">:</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;rachel&#39;</span><span class="p">:</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;raymond&#39;</span><span class="p">:</span> <span class="s1">&#39;red&#39;</span><span class="p">}</span>

<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">k</span>

<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">):</span>
        <span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
</pre></div>


<p>什么时候应该使用第二种而不是第一种方法？当你需要修改字典的时候。</p>
<blockquote>
<p>如果你在迭代一个东西的时候修改它，那就是在冒天下之大不韪，接下来发生什么都活该。</p>
</blockquote>
<p><code>d.keys()</code>把字典里所有的key都复制到一个列表里。然后你就可以修改字典了。</p>
<p>注意：如果在Python 3里迭代一个字典你得显示地写：<code>list(d.keys())</code>，因为<code>d.keys()</code>返回的是一个“字典视图”(一个提供字典key的动态视图的迭代器)。详情请看<a href="https://docs.python.org/3/library/stdtypes.html#dict-views">文档</a>。</p>
<h2>遍历一个字典的key和value</h2>
<div class="highlight"><pre><span></span><span class="c1"># 并不快，每次必须要重新哈希并做一次查找</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">k</span><span class="p">,</span> <span class="s1">&#39;---&gt;&#39;</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

<span class="c1"># 产生一个很大的列表</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">print</span> <span class="n">k</span><span class="p">,</span> <span class="s1">&#39;---&gt;&#39;</span><span class="p">,</span> <span class="n">v</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
    <span class="k">print</span> <span class="n">k</span><span class="p">,</span> <span class="s1">&#39;---&gt;&#39;</span><span class="p">,</span> <span class="n">v</span>
</pre></div>


<p><code>iteritems()</code>更好是因为它返回了一个迭代器。</p>
<p>注意：Python 3已经没有<code>iteritems()</code>了，<code>items()</code>的行为和<code>iteritems()</code>很接近。详情请看<a href="https://docs.python.org/3/library/stdtypes.html#dict-views">文档</a>。</p>
<h2>用key-value对构建字典</h2>
<div class="highlight"><pre><span></span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;raymond&#39;</span><span class="p">,</span> <span class="s1">&#39;rachel&#39;</span><span class="p">,</span> <span class="s1">&#39;matthew&#39;</span><span class="p">]</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">]</span>

<span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">izip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">colors</span><span class="p">))</span>
<span class="c1"># {&#39;matthew&#39;: &#39;blue&#39;, &#39;rachel&#39;: &#39;green&#39;, &#39;raymond&#39;: &#39;red&#39;}</span>
</pre></div>


<p>Python 3: <code>d = dict(zip(names, colors))</code></p>
<h2>用字典计数</h2>
<div class="highlight"><pre><span></span><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">]</span>

<span class="c1"># 简单，基本的计数方法。适合初学者起步时学习。</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">color</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">color</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">d</span><span class="p">[</span><span class="n">color</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># {&#39;blue&#39;: 1, &#39;green&#39;: 2, &#39;red&#39;: 3}</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
    <span class="n">d</span><span class="p">[</span><span class="n">color</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

<span class="c1"># 稍微潮点的方法，但有些坑需要注意，适合熟练的老手。</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
    <span class="n">d</span><span class="p">[</span><span class="n">color</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>


<h2>用字典分组 -- 第I部分和第II部分</h2>
<div class="highlight"><pre><span></span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;raymond&#39;</span><span class="p">,</span> <span class="s1">&#39;rachel&#39;</span><span class="p">,</span> <span class="s1">&#39;matthew&#39;</span><span class="p">,</span> <span class="s1">&#39;roger&#39;</span><span class="p">,</span>
         <span class="s1">&#39;betty&#39;</span><span class="p">,</span> <span class="s1">&#39;melissa&#39;</span><span class="p">,</span> <span class="s1">&#39;judith&#39;</span><span class="p">,</span> <span class="s1">&#39;charlie&#39;</span><span class="p">]</span>

<span class="c1"># 在这个例子，我们按name的长度分组</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
    <span class="n">key</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

<span class="c1"># {5: [&#39;roger&#39;, &#39;betty&#39;], 6: [&#39;rachel&#39;, &#39;judith&#39;], 7: [&#39;raymond&#39;, &#39;matthew&#39;, &#39;melissa&#39;, &#39;charlie&#39;]}</span>

<span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
    <span class="n">key</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">d</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
    <span class="n">key</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div>


<h2>字典的<code>popitem()</code>是原子的吗？</h2>
<div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;matthew&#39;</span><span class="p">:</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;rachel&#39;</span><span class="p">:</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;raymond&#39;</span><span class="p">:</span> <span class="s1">&#39;red&#39;</span><span class="p">}</span>

<span class="k">while</span> <span class="n">d</span><span class="p">:</span>
    <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">key</span><span class="p">,</span> <span class="s1">&#39;--&gt;&#39;</span><span class="p">,</span> <span class="n">value</span>
</pre></div>


<p><code>popitem</code>是原子的，所以多线程的时候没必要用锁包着它。</p>
<h2>连接字典</h2>
<div class="highlight"><pre><span></span><span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;user&#39;</span><span class="p">:</span> <span class="s1">&#39;guest&#39;</span><span class="p">}</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-u&#39;</span><span class="p">,</span> <span class="s1">&#39;--user&#39;</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-c&#39;</span><span class="p">,</span> <span class="s1">&#39;--color&#39;</span><span class="p">)</span>
<span class="n">namespace</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">([])</span>
<span class="n">command_line_args</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="n">namespace</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="p">}</span>

<span class="c1"># 下面是通常的作法，默认使用第一个字典，接着用环境变量覆盖它，最后用命令行参数覆盖它。</span>
<span class="c1"># 然而不幸的是，这种方法拷贝数据太疯狂。</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">defaults</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">)</span>
<span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">command_line_args</span><span class="p">)</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="n">ChainMap</span><span class="p">(</span><span class="n">command_line_args</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">,</span> <span class="n">defaults</span><span class="p">)</span>
</pre></div>


<p><code>ChainMap</code>在Python 3中加入。高效而优雅。</p>
<h2>提高可读性</h2>
<ul>
<li>位置参数和下标很漂亮</li>
<li>但关键字和名称更好</li>
<li>第一种方法对计算机来说很便利</li>
<li>第二种方法和人类思考方式一致</li>
</ul>
<h2>用关键字参数提高函数调用的可读性</h2>
<div class="highlight"><pre><span></span><span class="n">twitter_search</span><span class="p">(</span><span class="s1">&#39;@obama&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="n">twitter_search</span><span class="p">(</span><span class="s1">&#39;@obama&#39;</span><span class="p">,</span> <span class="n">retweets</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">numtweets</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">popular</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>


<p>第二种方法稍微(微秒级)慢一点，但为了代码的可读性和开发时间，值得。</p>
<h2>用<code>namedtuple</code>提高多个返回值的可读性</h2>
<div class="highlight"><pre><span></span><span class="c1"># 老的testmod返回值</span>
<span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
<span class="c1"># (0, 4)</span>
<span class="c1"># 测试结果是好是坏？你看不出来，因为返回值不清晰。</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="c1"># 新的testmod返回值, 一个namedtuple</span>
<span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
<span class="c1"># TestResults(failed=0, attempted=4)</span>
</pre></div>


<p><code>namedtuple</code>是<code>tuple</code>的子类，所以仍适用正常的元组操作，但它更友好。</p>
<p>创建一个<code>nametuple</code></p>
<div class="highlight"><pre><span></span><span class="n">TestResults</span> <span class="o">=</span> <span class="n">namedTuple</span><span class="p">(</span><span class="s1">&#39;TestResults&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;failed&#39;</span><span class="p">,</span> <span class="s1">&#39;attempted&#39;</span><span class="p">])</span>
</pre></div>


<h2>unpack序列</h2>
<div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="s1">&#39;Raymond&#39;</span><span class="p">,</span> <span class="s1">&#39;Hettinger&#39;</span><span class="p">,</span> <span class="mh">0x30</span><span class="p">,</span> <span class="s1">&#39;python@example.com&#39;</span>

<span class="c1"># 其它语言的常用方法/习惯</span>
<span class="n">fname</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">lname</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">age</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">email</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="n">fname</span><span class="p">,</span> <span class="n">lname</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">email</span> <span class="o">=</span> <span class="n">p</span>
</pre></div>


<p>第二种方法用了unpack元组，更快，可读性更好。</p>
<h2>更新多个变量的状态</h2>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">x</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">t</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">print</span> <span class="n">x</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>


<p>第一种方法的问题</p>
<ul>
<li>x和y是状态，状态应该在一次操作中更新，分几行的话状态会互相对不上，这经常是bug的源头。</li>
<li>操作有顺序要求</li>
<li>太底层太细节</li>
</ul>
<p>第二种方法抽象层级更高，没有操作顺序出错的风险而且更效率更高。</p>
<h2>同时状态更新</h2>
<div class="highlight"><pre><span></span><span class="n">tmp_x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">t</span>
<span class="n">tmp_y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">t</span>
<span class="n">tmp_dx</span> <span class="o">=</span> <span class="n">influence</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">tmp_dy</span> <span class="o">=</span> <span class="n">influence</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">tmp_x</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">tmp_y</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">tmp_dx</span>
<span class="n">dy</span> <span class="o">=</span> <span class="n">tmp_dy</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span>
                <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">t</span><span class="p">,</span>
                <span class="n">influence</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">),</span>
                <span class="n">influence</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">))</span>
</pre></div>


<h2>效率</h2>
<ul>
<li>优化的基本原则</li>
<li>除非必要，别无故移动数据</li>
<li>稍微注意一下用线性的操作取代O(n**2)的操作</li>
</ul>
<blockquote>
<p>总的来说，不要无故移动数据</p>
</blockquote>
<h2>连接字符串</h2>
<div class="highlight"><pre><span></span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;raymond&#39;</span><span class="p">,</span> <span class="s1">&#39;rachel&#39;</span><span class="p">,</span> <span class="s1">&#39;matthew&#39;</span><span class="p">,</span> <span class="s1">&#39;roger&#39;</span><span class="p">,</span>
         <span class="s1">&#39;betty&#39;</span><span class="p">,</span> <span class="s1">&#39;melissa&#39;</span><span class="p">,</span> <span class="s1">&#39;judith&#39;</span><span class="p">,</span> <span class="s1">&#39;charlie&#39;</span><span class="p">]</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="n">name</span>
<span class="k">print</span> <span class="n">s</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="k">print</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
</pre></div>


<h2>更新序列</h2>
<div class="highlight"><pre><span></span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;raymond&#39;</span><span class="p">,</span> <span class="s1">&#39;rachel&#39;</span><span class="p">,</span> <span class="s1">&#39;matthew&#39;</span><span class="p">,</span> <span class="s1">&#39;roger&#39;</span><span class="p">,</span>
         <span class="s1">&#39;betty&#39;</span><span class="p">,</span> <span class="s1">&#39;melissa&#39;</span><span class="p">,</span> <span class="s1">&#39;judith&#39;</span><span class="p">,</span> <span class="s1">&#39;charlie&#39;</span><span class="p">]</span>

<span class="k">del</span> <span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1"># 下面的代码标志着你用错了数据结构</span>
<span class="n">names</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">names</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;mark&#39;</span><span class="p">)</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="n">names</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="s1">&#39;raymond&#39;</span><span class="p">,</span> <span class="s1">&#39;rachel&#39;</span><span class="p">,</span> <span class="s1">&#39;matthew&#39;</span><span class="p">,</span> <span class="s1">&#39;roger&#39;</span><span class="p">,</span>
               <span class="s1">&#39;betty&#39;</span><span class="p">,</span> <span class="s1">&#39;melissa&#39;</span><span class="p">,</span> <span class="s1">&#39;judith&#39;</span><span class="p">,</span> <span class="s1">&#39;charlie&#39;</span><span class="p">])</span>

<span class="c1"># 用deque更有效率</span>
<span class="k">del</span> <span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">names</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
<span class="n">names</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="s1">&#39;mark&#39;</span><span class="p">)</span>
</pre></div>


<h2>装饰器和上下文管理</h2>
<ul>
<li>用于把业务和管理的逻辑分开</li>
<li>分解代码和提高代码重用性的干净优雅的好工具</li>
<li>起个好名字很关键</li>
<li>记住蜘蛛侠的格言：能力越大，责任越大</li>
</ul>
<h2>使用装饰器分离出管理逻辑</h2>
<div class="highlight"><pre><span></span><span class="c1"># 混着业务和管理逻辑，无法重用</span>
<span class="k">def</span> <span class="nf">web_lookup</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">saved</span><span class="o">=</span><span class="p">{}):</span>
    <span class="k">if</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">saved</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">saved</span><span class="p">[</span><span class="n">url</span><span class="p">]</span>
    <span class="n">page</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">saved</span><span class="p">[</span><span class="n">url</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span>
    <span class="k">return</span> <span class="n">page</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="nd">@cache</span>
<span class="k">def</span> <span class="nf">web_lookup</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">urllib</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>


<p>注意：Python 3.2开始加入了<code>functools.lru_cache</code>解决这个问题。</p>
<h2>分离临时上下文</h2>
<div class="highlight"><pre><span></span><span class="c1"># 保存旧的，创建新的</span>
<span class="n">old_context</span> <span class="o">=</span> <span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">50</span>
<span class="k">print</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">355</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">113</span><span class="p">)</span>
<span class="n">setcontext</span><span class="p">(</span><span class="n">old_context</span><span class="p">)</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">localcontext</span><span class="p">(</span><span class="n">Context</span><span class="p">(</span><span class="n">prec</span><span class="o">=</span><span class="mi">50</span><span class="p">)):</span>
    <span class="k">print</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">355</span><span class="p">)</span> <span class="o">/</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">113</span><span class="p">)</span>
</pre></div>


<p>译注：示例代码在使用标准库<code>decimal</code>，这个库已经实现好了<code>localcontext</code>。</p>
<h2>如何打开关闭文件</h2>
<div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.txt&#39;</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.txt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</pre></div>


<h2>如何使用锁</h2>
<div class="highlight"><pre><span></span><span class="c1"># 创建锁</span>
<span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

<span class="c1"># 使用锁的老方法</span>
<span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">print</span> <span class="s1">&#39;Critical section 1&#39;</span>
    <span class="k">print</span> <span class="s1">&#39;Critical section 2&#39;</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="c1"># 使用锁的新方法</span>
<span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
    <span class="k">print</span> <span class="s1">&#39;Critical section 1&#39;</span>
    <span class="k">print</span> <span class="s1">&#39;Critical section 2&#39;</span>
</pre></div>


<h2>分离出临时的上下文</h2>
<div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;somefile.tmp&#39;</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">ignored</span><span class="p">(</span><span class="ne">OSError</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;somefile.tmp&#39;</span><span class="p">)</span>
</pre></div>


<p><code>ignored</code>是Python 3.4加入的, <a href="http://docs.python.org/dev/library/contextlib.html#contextlib.ignored">文档</a>。</p>
<p>注意：<code>ignored</code> 实际上在标准库叫<code>suppress</code>(译注：<code>contextlib.supress</code>).</p>
<p>试试创建你自己的<code>ignored</code>上下文管理器。</p>
<div class="highlight"><pre><span></span><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">ignored</span><span class="p">(</span><span class="o">*</span><span class="n">exceptions</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">except</span> <span class="n">exceptions</span><span class="p">:</span>
        <span class="k">pass</span>
</pre></div>


<blockquote>
<p>把它放在你的工具目录，你也可以忽略异常</p>
</blockquote>
<p>译注：<code>contextmanager</code>在标准库<code>contextlib</code>中，通过装饰生成器函数，省去用<code>__enter__</code>和<code>__exit__</code>写上下文管理器。详情请看<a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager">文档</a>。</p>
<h2>分离临时上下文</h2>
<div class="highlight"><pre><span></span><span class="c1"># 临时把标准输出重定向到一个文件，然后再恢复正常</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;help.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">oldstdout</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">f</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">help</span><span class="p">(</span><span class="nb">pow</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">oldstdout</span>
</pre></div>


<h3>更好的写法</h3>
<div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;help.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">redirect_stdout</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">help</span><span class="p">(</span><span class="nb">pow</span><span class="p">)</span>
</pre></div>


<p><code>redirect_stdout</code>在Python 3.4加入(译注：<code>contextlib.redirect_stdout</code>)， <a href="http://bugs.python.org/issue15805">bug反馈</a>。</p>
<p>实现你自己的<code>redirect_stdout</code>上下文管理器。</p>
<div class="highlight"><pre><span></span><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">redirect_stdout</span><span class="p">(</span><span class="n">fileobj</span><span class="p">):</span>
    <span class="n">oldstdout</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">fileobj</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">fieldobj</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">oldstdout</span>
</pre></div>


<h2>简洁的单句表达</h2>
<p>两个冲突的原则：</p>
<ul>
<li>一行不要有太多逻辑</li>
<li>不要把单一的想法拆分成多个部分</li>
</ul>
<p>Raymond的原则：</p>
<ul>
<li>一行代码的逻辑等价于一句自然语言</li>
</ul>
<h2>列表解析和生成器</h2>
<div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">i</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="k">print</span> <span class="nb">sum</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>


<p>更好的方法</p>
<div class="highlight"><pre><span></span><span class="k">print</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</pre></div>


<p>第一种方法说的是你在做什么，第二种方法说的是你想要什么。</p></div>
    <footer>
<p class="meta">
  <span class="byline author vcard">
    Posted by <span class="fn">
        <a href="/author/light-xue">Light Xue</a>
    </span>
  </span>
<time datetime="2017-06-18T17:55:00+08:00" pubdate>2017-06-18</time>  <!--<span class="categories">-->
    <!--<a class='category' href='/category/python'>Python</a>-->
  <!--</span>-->
  <!---->
  <!--<span class="categories">-->
    <!---->
    <!--<a class="category" href="/tag/python">Python</a>-->
    <!---->
  <!--</span>-->
  <!---->
</p><p class="meta">
本作品由<a xmlns:cc="http://creativecommons.org/ns#" target="_blank" href="http://www.lightxue.com" property="cc:attributionName" rel="cc:attributionURL">www.lightxue.com</a>采用<a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/deed.zh">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可。
<p>
<div class="sharing">
</div>    </footer>
  </article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
  </section>
</div>
<aside class="sidebar">
  <section>
    <h1>最新文章</h1>
    <ul id="recent_posts">
      <li class="post">
          <a href="/understand-python-decorator-the-easy-way">简单地理解Python的装饰器</a>
      </li>
      <li class="post">
          <a href="/transforming-code-into-beautiful-idiomatic-python">[译]让你的Python代码优雅又地道</a>
      </li>
      <li class="post">
          <a href="/python-internals-locate-source-code">Python源码寻宝记——地图篇</a>
      </li>
      <li class="post">
          <a href="/python-internals-introductory">Python源码寻宝记——挖坑不埋</a>
      </li>
      <li class="post">
          <a href="/edm-practices-notes">邮件发送实践经验</a>
      </li>
    </ul>
  </section>
  <section>

    <h1>分类</h1>
    <ul id="recent_posts">
        <li><a href="/category/c">C</a></li>
        <li><a href="/category/linux">Linux</a></li>
        <li><a href="/category/misc">Misc</a></li>
        <li><a href="/category/python">Python</a></li>
    </ul>
  </section>

  <!--<section>-->
  <!--<h1>Tags</h1>-->
  <!---->
    <!--<a href="/tag/algorithm">algorithm</a>,-->
  <!---->
    <!--<a href="/tag/python">Python</a>,-->
  <!---->
    <!--<a href="/tag/shell">shell</a>,-->
  <!---->
    <!--<a href="/tag/linux">Linux</a>,-->
  <!---->
    <!--<a href="/tag/c">C</a>-->
  <!---->
  <!--</section>-->



</aside>    </div>
  </div>
  <footer role="contentinfo">    Copyright &copy;  2013&ndash;2017  Light Xue &mdash;
  <span class="credit">Powered by <a target="_blank" href="http://getpelican.com">Pelican</a></span>
</p></footer>
  <script src="/theme/js/modernizr-2.0.js"></script>
  <script src="/theme/js/ender.js"></script>
  <script src="/theme/js/octopress.js" type="text/javascript"></script>
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-42436465-3']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-42436465-3');
    ga('send', 'pageview');
    </script>
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8a9edae11717cd734925510200712026";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  <script type="text/javascript">
    var disqus_shortname = '0xfee1c00l';
    var disqus_identifier = '/transforming-code-into-beautiful-idiomatic-python';
    var disqus_url = 'http://www.lightxue.com/transforming-code-into-beautiful-idiomatic-python';
    var disqus_title = '[译]让你的Python代码优雅又地道';
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = "//" + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
  </script>
</body>
</html>