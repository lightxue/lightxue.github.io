<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="zh"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>简单地理解Python的装饰器 &mdash; 0xFEE1C001</title>
  <meta name="author" content="Light Xue">
  <meta name="description" content="用简单的方式轻松地理解Python的装饰器" />

  <link href="/feeds/atom.xml" type="application/atom+xml" rel="alternate"
        title="0xFEE1C001 Atom Feed" />





  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">


    <link href="/favicon.png" rel="icon">

  <link href="/theme/css/main.css" media="screen, projection"
        rel="stylesheet" type="text/css">

  <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
</head>

<body>
  <header role="banner"><hgroup>
  <h1><a href="/">0xFEE1C001</a></h1>
    <h2>Where there is a shell, there is a way</h2>
</hgroup></header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/feeds/atom.xml" rel="subscribe-atom">Atom</a></li>
</ul>


<ul class="main-navigation">
    <li><a href="/">首页</a></li>
    <li><a href="http://tools.lightxue.com">程序员工具</a></li>
</ul></nav>
  <div id="main">
    <div id="content">
<div>
  <article class="hentry" role="article">
<header>
      <h1 class="entry-title">简单地理解Python的装饰器</h1>
    <p class="meta">
<time datetime="2017-06-26T01:00:00+08:00" pubdate>2017-06-26</time>    </p>
</header>

  <div class="entry-content"><p>Python有大量强大又贴心的特性，如果要列个最受欢迎排行榜，那么装饰器绝对会在其中。</p>
<p>刚接触装饰器，会觉得代码不多却难以理解。其实装饰器的语法本身挺简单的，复杂是因为同时混杂了其它的概念。下面我们一起抛去无关概念，简单地理解下Python的装饰器。</p>


<h2>装饰器的原理</h2>
<p>在解释器下跑个装饰器的例子，直观地感受一下。</p>
<div class="highlight"><pre><span></span><span class="c1"># make_bold就是装饰器，实现方式这里略去</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nd">@make_bold</span>
<span class="o">...</span> <span class="k">def</span> <span class="nf">get_content</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_content</span><span class="p">()</span>
<span class="s1">&#39;&lt;b&gt;hello world&lt;/b&gt;&#39;</span>
</pre></div>


<p>被<code>make_bold</code>装饰的<code>get_content</code>，调用后返回结果会自动被<code>b</code>标签包住。怎么做到的呢，简单4步就能明白了。</p>
<h3>1. 函数是对象</h3>
<p>我们定义个<code>get_content</code>函数。这时<code>get_content</code>也是个对象，它能做所有对象的操作。</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_content</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>
</pre></div>


<p>它有<code>id</code>，有<code>type</code>，有值。</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; id(get_content)
140090200473112
&gt;&gt;&gt; type(get_content)
&lt;class &#39;function&#39;&gt;
&gt;&gt;&gt; get_content
&lt;function get_content at 0x7f694aa2be18&gt;
</pre></div>


<p>跟其他对象一样可以被赋值给其它变量。</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">func_name</span> <span class="o">=</span> <span class="n">get_content</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">func_name</span><span class="p">()</span>
<span class="s1">&#39;hello world&#39;</span>
</pre></div>


<p>它可以当参数传递，也可以当返回值</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">bar</span><span class="p">):</span>
<span class="o">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">bar</span><span class="p">())</span>
<span class="o">...</span>     <span class="k">return</span> <span class="n">bar</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">func</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">get_content</span><span class="p">)</span>
<span class="n">hello</span> <span class="n">world</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">func</span><span class="p">()</span>
<span class="s1">&#39;hello world&#39;</span>
</pre></div>


<h3>2. 自定义函数对象</h3>
<p>我们可以用<code>class</code>来构造函数对象。有成员函数<code>__call__</code>的就是函数对象了，函数对象被调用时正是调用的<code>__call__</code>。</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FuncObj</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Initialize&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Hi&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>


<p>我们来调用看看。可以看到，<strong>函数对象的使用分两步：构造和调用</strong>(同学们注意了，这是考点)。</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">fo</span> <span class="o">=</span> <span class="n">FuncObj</span><span class="p">(</span><span class="s1">&#39;python&#39;</span><span class="p">)</span>
<span class="n">Initialize</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">fo</span><span class="p">()</span>
<span class="n">Hi</span> <span class="n">python</span>
</pre></div>


<h3>3. <code>@</code>是个语法糖</h3>
<p>装饰器的<code>@</code>没有做什么特别的事，不用它也可以实现一样的功能，只不过需要更多的代码。</p>
<div class="highlight"><pre><span></span><span class="nd">@make_bold</span>
<span class="k">def</span> <span class="nf">get_content</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>

<span class="c1"># 上面的代码等价于下面的</span>

<span class="k">def</span> <span class="nf">get_content</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>
<span class="n">get_content</span> <span class="o">=</span> <span class="n">make_bold</span><span class="p">(</span><span class="n">get_content</span><span class="p">)</span>
</pre></div>


<p><code>make_bold</code>是个函数，要求入参是函数对象，返回值是函数对象。<code>@</code>的语法糖其实是省去了上面最后一行代码，使可读性更好。用了装饰器后，每次调用<code>get_content</code>，真正调用的是<code>make_bold</code>返回的函数对象。</p>
<h3>4. 用类实现装饰器</h3>
<p>入参是函数对象，返回是函数对象，如果第2步里的类的构造函数改成入参是个函数对象，不就正好符合要求吗？我们来试试实现<code>make_bold</code>。</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">make_bold</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Initialize&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Call&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;b&gt;{}&lt;/b&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">())</span>
</pre></div>


<p>大功告成，看看能不能用。</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="nd">@make_bold</span>
<span class="o">...</span> <span class="k">def</span> <span class="nf">get_content</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>
<span class="o">...</span>
<span class="n">Initialize</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_content</span><span class="p">()</span>
<span class="n">Call</span>
<span class="s1">&#39;&lt;b&gt;hello world&lt;/b&gt;&#39;</span>
</pre></div>


<p>成功实现装饰器！是不是很简单？</p>
<p>这里分析一下之前强调的<strong>构造</strong>和<strong>调用</strong>两个过程。我们去掉<code>@</code>语法糖好理解一些。</p>
<div class="highlight"><pre><span></span><span class="c1"># 构造，使用装饰器时构造函数对象，调用了__init__</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_content</span> <span class="o">=</span> <span class="n">make_bold</span><span class="p">(</span><span class="n">get_content</span><span class="p">)</span>
<span class="n">Initialize</span>

<span class="c1"># 调用，实际上直接调用的是make_bold构造出来的函数对象</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_content</span><span class="p">()</span>
<span class="n">Call</span>
<span class="s1">&#39;&lt;b&gt;hello world&lt;/b&gt;&#39;</span>
</pre></div>


<p>到这里就彻底清楚了，完结撒花，可以关掉网页了~~~(如果只是想知道装饰器原理的话)</p>
<h2>函数版装饰器</h2>
<p>阅读源码时，经常见到用嵌套函数实现的装饰器，怎么理解？同样仅需4步。</p>
<h3>1. <code>def</code>的函数对象初始化</h3>
<p>用<code>class</code>实现的函数对象很容易看到什么时候<strong>构造</strong>的，那<code>def</code>定义的函数对象什么时候<strong>构造</strong>的呢？</p>
<div class="highlight"><pre><span></span><span class="c1"># 这里的全局变量删去了无关的内容</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">globals</span><span class="p">()</span>
<span class="p">{}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">pass</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">globals</span><span class="p">()</span>
<span class="p">{</span><span class="s1">&#39;func&#39;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">func</span> <span class="n">at</span> <span class="mh">0x10f5baf28</span><span class="o">&gt;</span><span class="p">}</span>
</pre></div>


<p>不像一些编译型语言，程序在启动时函数已经构造那好了。上面的例子可以看到，执行到<code>def</code>会才构造出一个函数对象，并赋值给变量<code>make_bold</code>。</p>
<p>这段代码和下面的代码效果是很像的。</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NoName</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="n">func</span> <span class="o">=</span> <span class="n">NoName</span><span class="p">()</span>
</pre></div>


<h3>2. 嵌套函数</h3>
<p>Python的函数可以嵌套定义。</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">outer</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Before def:&#39;</span><span class="p">,</span> <span class="nb">locals</span><span class="p">())</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="k">pass</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;After def:&#39;</span><span class="p">,</span> <span class="nb">locals</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">inner</span>
</pre></div>


<p><code>inner</code>是在<code>outer</code>内定义的，所以算<code>outer</code>的局部变量。执行到<code>def inner</code>时函数对象才创建，因此每次调用<code>outer</code>都会创建一个新的<code>inner</code>。下面可以看出，每次返回的<code>inner</code>是不同的。</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; outer()
Before def: {}
After def: {&#39;inner&#39;: &lt;function outer.&lt;locals&gt;.inner at 0x7f0b18fa0048&gt;}
&lt;function outer.&lt;locals&gt;.inner at 0x7f0b18fa0048&gt;
&gt;&gt;&gt; outer()
Before def: {}
After def: {&#39;inner&#39;: &lt;function outer.&lt;locals&gt;.inner at 0x7f0b18fa00d0&gt;}
&lt;function outer.&lt;locals&gt;.inner at 0x7f0b18fa00d0&gt;
</pre></div>


<h3>3. 闭包</h3>
<p>嵌套函数有什么特别之处？因为有闭包。</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">outer</span><span class="p">():</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;hello world&#39;</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inner</span>
</pre></div>


<p>下面的试验表明，<code>inner</code>可以访问到<code>outer</code>的局部变量<code>msg</code>。</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">func</span> <span class="o">=</span> <span class="n">outer</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">func</span><span class="p">()</span>
<span class="n">hello</span> <span class="n">world</span>
</pre></div>


<p>闭包有2个特点</p>
<ol>
<li><code>inner</code>能访问<code>outer</code>及其祖先函数的命名空间内的变量(局部变量，函数参数)。</li>
<li>调用<code>outer</code>已经返回了，但是它的命名空间被返回的<code>inner</code>对象引用，所以还不会被回收。</li>
</ol>
<p>这部分想深入可以去了解Python的LEGB规则。</p>
<h3>4. 用函数实现装饰器</h3>
<p>装饰器要求入参是函数对象，返回值是函数对象，嵌套函数完全能胜任。</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_bold</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Initialize&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Call&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;b&gt;{}&lt;/b&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>


<p>用法跟类实现的装饰器一样。可以去掉<code>@</code>语法糖分析下<strong>构造</strong>和<strong>调用</strong>的时机。</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="nd">@make_bold</span>
<span class="o">...</span> <span class="k">def</span> <span class="nf">get_content</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>
<span class="o">...</span>
<span class="n">Initialize</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_content</span><span class="p">()</span>
<span class="n">Call</span>
<span class="s1">&#39;&lt;b&gt;hello world&lt;/b&gt;&#39;</span>
</pre></div>


<p>因为返回的<code>wrapper</code>还在引用着，所以存在于<code>make_bold</code>命名空间的<code>func</code>不会消失。<code>make_bold</code>可以装饰多个函数，<code>wrapper</code>不会调用混淆，因为每次调用<code>make_bold</code>，都会有创建新的命名空间和新的<code>wrapper</code>。</p>
<p>到此函数实现装饰器也理清楚了，完结撒花，可以关掉网页了~~~(后面是使用装饰的常见问题)</p>
<h2>常见问题</h2>
<h3>1. 怎么实现带参数的装饰器？</h3>
<p>带参数的装饰器，有时会异常的好用。我们看个例子。</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="nd">@make_header</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">...</span> <span class="k">def</span> <span class="nf">get_content</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_content</span><span class="p">()</span>
<span class="s1">&#39;&lt;h2&gt;hello world&lt;/h2&gt;&#39;</span>
</pre></div>


<p>怎么做到的呢？其实这跟装饰器语法没什么关系。去掉<code>@</code>语法糖会变得很容易理解。</p>
<div class="highlight"><pre><span></span><span class="nd">@make_header</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_content</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>

<span class="c1"># 等价于</span>

<span class="k">def</span> <span class="nf">get_content</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>
<span class="n">unnamed_decorator</span> <span class="o">=</span> <span class="n">make_header</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">get_content</span> <span class="o">=</span> <span class="n">unnamed_decorator</span><span class="p">(</span><span class="n">get_content</span><span class="p">)</span>
</pre></div>


<p>上面代码中的<code>unnamed_decorator</code>才是真正的装饰器，<code>make_header</code>是个普通的函数，它的返回值是装饰器。</p>
<p>来看一下实现的代码。</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_header</span><span class="p">(</span><span class="n">level</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Create decorator&#39;</span><span class="p">)</span>

    <span class="c1"># 这部分跟通常的装饰器一样，只是wrapper通过闭包访问了变量level</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Initialize&#39;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Call&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="s1">&#39;&lt;h{0}&gt;{1}&lt;/h{0}&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">func</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">wrapper</span>

    <span class="c1"># make_header返回装饰器</span>
    <span class="k">return</span> <span class="n">decorator</span>
</pre></div>


<p>看了实现代码，装饰器的<strong>构造</strong>和<strong>调用</strong>的时序已经很清楚了。</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="nd">@make_header</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="o">...</span> <span class="k">def</span> <span class="nf">get_content</span><span class="p">():</span>
<span class="o">...</span>     <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>
<span class="o">...</span>
<span class="n">Create</span> <span class="n">decorator</span>
<span class="n">Initialize</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_content</span><span class="p">()</span>
<span class="n">Call</span>
<span class="s1">&#39;&lt;h2&gt;hello world&lt;/h2&gt;&#39;</span>
</pre></div>


<h3>2. 如何装饰有参数的函数？</h3>
<p>为了有条理地理解装饰器，之前例子里的被装饰函数有意设计成无参的。我们来看个例子。</p>
<div class="highlight"><pre><span></span><span class="nd">@make_bold</span>
<span class="k">def</span> <span class="nf">get_login_tip</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;Welcome back, {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div>


<p>最直接的想法是把<code>get_login_tip</code>的参数透传下去。</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">make_bold</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;b&gt;{}&lt;/b&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
</pre></div>


<p>如果被装饰的函数参数是明确固定的，这么写是没有问题的。但是<code>make_bold</code>明显不是这种场景。它既需要装饰没有参数的<code>get_content</code>，又需要装饰有参数的<code>get_login_tip</code>。这时候就需要可变参数了。</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">make_bold</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;b&gt;{}&lt;/b&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
</pre></div>


<p>当装饰器不关心被装饰函数的参数，或是被装饰函数的参数多种多样的时候，可变参数非常合适。可变参数不属于装饰器的语法内容，这里就不深入探讨了。</p>
<h3>3. 一个函数能否被多个装饰器装饰？</h3>
<p>下面这么写合法吗？</p>
<div class="highlight"><pre><span></span><span class="nd">@make_italic</span>
<span class="nd">@make_bold</span>
<span class="k">def</span> <span class="nf">get_content</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>
</pre></div>


<p>合法。上面的的代码和下面等价，留意一下装饰的顺序。</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_content</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>
<span class="n">get_content</span> <span class="o">=</span> <span class="n">make_bold</span><span class="p">(</span><span class="n">get_content</span><span class="p">)</span> <span class="c1"># 先装饰离函数定义近的</span>
<span class="n">get_content</span> <span class="o">=</span> <span class="n">make_italic</span><span class="p">(</span><span class="n">get_content</span><span class="p">)</span>
</pre></div>


<h3>4. <code>functools.wraps</code>有什么用？</h3>
<p>Python的装饰器倍感贴心的地方是对调用方透明。调用方完全不知道也不需要知道调用的函数被装饰了。这样我们就能在调用方的代码完全不改动的前提下，给函数patch功能。</p>
<p>为了对调用方透明，装饰器返回的对象要伪装成被装饰的函数。伪装得越像，对调用方来说差异越小。有时光伪装函数名和参数是不够的，因为Python的函数对象有一些元信息调用方可能读取了。为了连这些元信息也伪装上，<code>functools.wraps</code>出场了。它能用于把被调用函数的<code>__module__</code>，<code>__name__</code>，<code>__qualname__</code>，<code>__doc__</code>，<code>__annotations__</code>赋值给装饰器返回的函数对象。</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">functools</span>

<span class="k">def</span> <span class="nf">make_bold</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;b&gt;{}&lt;/b&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>


<p>对比一下效果。</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="nd">@make_bold</span>
<span class="o">...</span> <span class="k">def</span> <span class="nf">get_content</span><span class="p">():</span>
<span class="o">...</span>     <span class="s1">&#39;&#39;&#39;Return page content&#39;&#39;&#39;</span>
<span class="o">...</span>     <span class="k">return</span> <span class="s1">&#39;hello world&#39;</span>

<span class="c1"># 不用functools.wraps的结果</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_content</span><span class="o">.</span><span class="vm">__name__</span>
<span class="s1">&#39;wrapper&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_content</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="o">&gt;&gt;&gt;</span>

<span class="c1"># 用functools.wraps的结果</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_content</span><span class="o">.</span><span class="vm">__name__</span>
<span class="s1">&#39;get_content&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">get_content</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="s1">&#39;Return page content&#39;</span>
</pre></div>


<p>实现装饰器时往往不知道调用方会怎么用，所以养成好习惯加上<code>functools.wraps</code>吧。</p>
<p>这次是真·完结了，有疑问请留言，撒花吧~~~</p></div>
    <footer>
<p class="meta">
  <span class="byline author vcard">
    Posted by <span class="fn">
        <a href="/author/light-xue">Light Xue</a>
    </span>
  </span>
<time datetime="2017-06-26T01:00:00+08:00" pubdate>2017-06-26</time>  <!--<span class="categories">-->
    <!--<a class='category' href='/category/python'>Python</a>-->
  <!--</span>-->
  <!---->
  <!--<span class="categories">-->
    <!---->
    <!--<a class="category" href="/tag/python">Python</a>-->
    <!---->
  <!--</span>-->
  <!---->
</p><p class="meta">
本作品由<a xmlns:cc="http://creativecommons.org/ns#" target="_blank" href="http://www.lightxue.com" property="cc:attributionName" rel="cc:attributionURL">www.lightxue.com</a>采用<a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/deed.zh">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可。
<p>
<div class="sharing">
</div>    </footer>
  </article>

  <section>
    <h1>评论</h1>
    <div id="gitment-container" aria-live="polite"><noscript>请打开JavaScript查看评论</noscript>
</div>
  </section>
</div>
<aside class="sidebar">
  <section>
    <h1>最新文章</h1>
    <ul id="recent_posts">
      <li class="post">
          <a href="/understand-python-decorator-the-easy-way">简单地理解Python的装饰器</a>
      </li>
      <li class="post">
          <a href="/transforming-code-into-beautiful-idiomatic-python">[译]让你的Python代码优雅又地道</a>
      </li>
      <li class="post">
          <a href="/python-internals-locate-source-code">Python源码寻宝记——地图篇</a>
      </li>
      <li class="post">
          <a href="/python-internals-introductory">Python源码寻宝记——挖坑不埋</a>
      </li>
      <li class="post">
          <a href="/edm-practices-notes">邮件发送实践经验</a>
      </li>
    </ul>
  </section>
  <section>

    <h1>分类</h1>
    <ul id="recent_posts">
        <li><a href="/category/c">C</a></li>
        <li><a href="/category/linux">Linux</a></li>
        <li><a href="/category/misc">Misc</a></li>
        <li><a href="/category/python">Python</a></li>
    </ul>
  </section>

  <!--<section>-->
  <!--<h1>Tags</h1>-->
  <!---->
    <!--<a href="/tag/python">Python</a>,-->
  <!---->
    <!--<a href="/tag/linux">Linux</a>,-->
  <!---->
    <!--<a href="/tag/shell">shell</a>,-->
  <!---->
    <!--<a href="/tag/c">C</a>,-->
  <!---->
    <!--<a href="/tag/algorithm">algorithm</a>-->
  <!---->
  <!--</section>-->



</aside>    </div>
  </div>
  <footer role="contentinfo">    Copyright &copy;  2013&ndash;2017  Light Xue &mdash;
  <span class="credit">Powered by <a target="_blank" href="http://getpelican.com">Pelican</a></span>
</p></footer>
  <script src="/theme/js/modernizr-2.0.js"></script>
  <script src="/theme/js/ender.js"></script>
  <script src="/theme/js/octopress.js" type="text/javascript"></script>
    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-42436465-3']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-42436465-3');
    ga('send', 'pageview');
    </script>
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8a9edae11717cd734925510200712026";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  id: location.pathname,
  owner: 'lightxue',
  repo: 'lightxue.github.io',
  oauth: {
    client_id: 'cfbdea1160f74d535db2',
    client_secret: '5616e795360075c1d526671e6b272f3da57ac501',
  },
})
gitment.render('gitment-container')
</script>
</body>
</html>