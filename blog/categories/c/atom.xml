<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C | 0xFEE1C001]]></title>
  <link href="http://lightxue.github.io/blog/categories/c/atom.xml" rel="self"/>
  <link href="http://lightxue.github.io/"/>
  <updated>2015-08-03T02:27:10+08:00</updated>
  <id>http://lightxue.github.io/</id>
  <author>
    <name><![CDATA[Light Xue]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于barrier]]></title>
    <link href="http://lightxue.github.io/about-barriers"/>
    <updated>2015-04-10T16:50:24+08:00</updated>
    <id>http://lightxue.github.io/about-barriers</id>
    <content type="html"><![CDATA[<p>再次收到John Smith的来稿，为了你这篇稿子，我停笔一年了呀。</p>

<p>memory barrier内存屏障，一种非常底层的同步原语，是memory ordering的一部分。
使用内存屏障可以阻止编译器或cpu对内存的乱序访问，其中阻止编译时期重排的叫做
compiler barrier，阻止运行时期重排的叫做memory barrier。</p>

<!-- more -->


<h2>一. compiler barrier</h2>

<p>```c</p>

<h1>define barrier()   <strong>asm</strong> <strong>volatile</strong>(&ldquo;&rdquo;:::&ldquo;memory&rdquo;)</h1>

<p>```</p>

<p>看开源项目代码可能偶尔会看上面这样的内嵌汇编:</p>

<ol>
<li>内嵌汇编的格式为<code>__asm__</code> (&ldquo;asm statement&rdquo; : outputs : inputs : registers-modified)</li>
<li><code>__asm__</code>用于提示编译器在这里插入汇编代码</li>
<li><code>__volatile__</code>用于告诉编译器，严禁将此处的汇编代码和其他语句进行重排优化，所得即所见</li>
<li><code>"":::</code>空的汇编语句，实际上不做任何事情</li>
<li><code>"memory"</code>强制编译器假设RAM所有内存单元均被汇编指令修改，cpu的registers和cache的缓存数据将invalidate，cpu不得不在需要的时候重新从内存读取数据</li>
<li>这条语句实际上不生成任何代码，但是会让gcc在barrier()之后刷新寄存器对变量的分配</li>
</ol>


<p>举个例子，考虑下面这段代码:
```c
for ( ;; )
{</p>

<pre><code>struct task_struct *owner;

owner = lock-&gt;owner;
if (owner &amp;&amp; !mutex_spin_on_owner(lock, owner))
    break;
/* ... */
</code></pre>

<p>}
```</p>

<p>这段代码含义大概是自旋的去获取一个mutex, 乍看一下没有问题。但是optimize编译下，compiler发现
循环里面完全没有去修改<code>lock-&gt;owner</code>嘛，没必要每次都取值。然后这段代码可能会优化为这样:</p>

<p>```c
owner = lock->owner;
for ( ;; )
{</p>

<pre><code>if (owner &amp;&amp; !mutex_spin_on_owner(lock, owner))
    break;
</code></pre>

<p>}
```</p>

<p>这肯定不是你想要的结果，而且极有可能出现死循环。</p>

<p>多线程情况下，编译器优化有可能会忽略<code>lock-&gt;owner</code>会被其他线程修改的情况。compiler barrier可以告诉编译器这里禁止优化，每次都从内存里面取<code>lock-&gt;owner</code>的值。修改后：</p>

<p>```c
for ( ;; )
{</p>

<pre><code>struct task_struct *owner;
barrier();

owner = lock-&gt;owner;
if (owner &amp;&amp; !mutex_spin_on_owner(lock, owner))
    break;
/* ... */
</code></pre>

<p>}
```</p>

<p>注：这里不用compiler barrier，<code>onwer = (volatile struct task_struct *)(lock-&gt;owner)</code>;
直接强转为volatile指针也可以解决问题。</p>

<h2>二. memory barrier</h2>

<p>```c</p>

<h1>define mb()        <strong>asm</strong> <strong>volatile</strong>(&ldquo;lock; addl $0, 0(%%rsp)&rdquo;:::&ldquo;memory&rdquo;)</h1>

<h1>define rmb()       mb()</h1>

<h1>define wmb()       <strong>asm</strong> <strong>volatile</strong>(&ldquo;&rdquo;:::&ldquo;memory&rdquo;)</h1>

<p>```</p>

<p>上面三个分别是读写内存屏障，读内存屏障和写内存屏障，在常见的x86/x64体系下，通常使用<code>lock</code>指令前缀
加上一个空操作来实现memory barrier, 注意当然不能是真的nop指令，linux中采用<code>addl $0, 0(%esp)</code>。</p>

<p>memory barrier可以保证运行时期的内存访问次序不被重排，保证程序的执行看上去满足顺序一致性。<code>volatile</code>关键字无法做到这一点，所以<code>volatile</code>不能保证是一个memory barrier。</p>

<p>另外也不能指望独立的memory barrier能不做很多事情，mb往往是成对出现的。</p>

<p>考虑下面这种情况，机器有两个核心，x和y都被初始化为0：
```c
CPU 0                   CPU 1</p>

<p>x = 1;                  r1 = y;
mb();                   mb();
y = 1;                  r2 = x;
```</p>

<p>CPU 0和CPU 1走完所有语句之后，总共有下面三种可能:</p>

<ol>
<li><p>r1 == 0 &amp;&amp; r2 == 0: CPU 0在CPU1执行完之后才开始</p></li>
<li><p>r1 == 0 &amp;&amp; r2 == 1: CPU 0和CPU 1物理上并行执行</p></li>
<li><p>r1 == 1 &amp;&amp; r2 == 1: CPU 1在CPU 0执行完之后才开始</p></li>
</ol>


<p>只有<code>r1 == 1 &amp;&amp; r2 == 0</code>这种输出被禁止了，如果这种情况真的出现，那你可以报警了。
这种情况仅仅当CPU 0或CPU 1出现乱序执行的时候才会出现，mb就是为了禁止乱序执行的。
目前Intel的CPU都遵循处理一致性，所有的写操作都遵循程序顺序，不会越过前面的读写操作，不过由于未来可能
会采用更弱的内存一致性模型，在代码里面适当的加上mb保证内存事件的次序仍然是必要的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[strlen的实现方法]]></title>
    <link href="http://lightxue.github.io/strlen-implementation"/>
    <updated>2013-12-07T22:23:46+08:00</updated>
    <id>http://lightxue.github.io/strlen-implementation</id>
    <content type="html"><![CDATA[<p>感谢<a href="https://plus.google.com/u/0/102034236640204820044">John Smith</a>来稿，笔风太有趣了，能当本博的专栏作家吗？</p>

<!--more-->


<p>```c</p>

<pre><code>size_t strlen(const char* str)
{
    size_t len = 0;
    while (*str++)
        len++;
    return len;
}
</code></pre>

<p>```</p>

<p>这大概是通常的写法，或者是像C语言程序设计的示例
```c</p>

<pre><code>int strlen(char* s)
{
    char *p = s;
    while(*p++)
        ;
    return p - s;
}
</code></pre>

<p>```</p>

<p>和某B偶然说到这个函数，那B说面试的时候老大问了strlen的写法，他当时用了一种
比较快速的方法。第一反应这货还有快速实现？怎么搞都得遍历完这个字符串，O(n)没跑了，你丫忽悠我。</p>

<p>答曰不是，然后上网去搜了一个glibc的strlen实现。大概如下：
```c</p>

<pre><code>size_t strlen (const char *str)
{
    const char *char_ptr;
    const unsigned long int *longword_ptr;
    unsigned long int longword, magic_bits, himagic, lomagic;

    for (char_ptr = str; ((unsigned long int) char_ptr
            &amp; (sizeof (longword) - 1)) != 0;
                ++char_ptr)
        if (*char_ptr == '\0')
            return char_ptr - str;

    longword_ptr = (unsigned long int *) char_ptr;

    magic_bits = 0x7efefeffL;
    himagic = 0x80808080L;
    lomagic = 0x01010101L;
    if (sizeof (longword) &gt; 4)
    {
        magic_bits = ((0x7efefefeL &lt;&lt; 16) &lt;&lt; 16) | 0xfefefeffL;
        himagic = ((himagic &lt;&lt; 16) &lt;&lt; 16) | himagic;
        lomagic = ((lomagic &lt;&lt; 16) &lt;&lt; 16) | lomagic;
    }
    if (sizeof (longword) &gt; 8)
        abort ();

    for (;;)
    {
        longword = *longword_ptr++;

        if (((longword - lomagic) &amp; himagic) != 0)
        {
            const char *cp = (const char *) (longword_ptr - 1);

            if (cp[0] == 0)
                return cp - str;
            if (cp[1] == 0)
                return cp - str + 1;
            if (cp[2] == 0)
                return cp - str + 2;
            if (cp[3] == 0)
                return cp - str + 3;
            if (sizeof (longword) &gt; 4)
            {
                if (cp[4] == 0)
                    return cp - str + 4;
                if (cp[5] == 0)
                    return cp - str + 5;
                if (cp[6] == 0)
                    return cp - str + 6;
                if (cp[7] == 0)
                    return cp - str + 7;
            }
        }
    }
}
</code></pre>

<p>```</p>

<p>艹，这么长(你这么想了，你一定这么想了)。</p>

<p>大概看了下，主要思想是一次取4/8个字节的数据进行判断。减少了将数据从内存搬到寄存器的指令次数。碉堡了，简直碉堡了。</p>

<p>以32位机器为例。</p>

<p>第一步地址4字节对齐。将地址与上<code>0x03</code>，抹掉前面的bits，留下最后两位，检查是否为0，为0则地址是4字节对齐的退出循环，否则地址+1。</p>

<p>第二步4字节作步长，检查取到的4字节中是否有<code>\0</code>，有的话，return 长度，没有继续往后走。检查是否有<code>\0</code>，是通过 <code>(x - 0x01010101L) &amp; 0x80808080L != 0</code>来做的。至于为啥可以这么做，自行列竖式试验下就知道了。如果有<code>\0</code>，遍历那4个字节，看具体是哪个字节是<code>\0</code>。</p>

<p>至此，实现方式已经清楚了。</p>

<p>但是这种方式实际上对于非ascii字符串是有问题的，会误判。所谓步子迈大了容易扯着tama。 unicode，GBK啥的，虽然函数不会出错，但是效率退化到和普通遍历一样了。 GBK是这样编码的好像，比如两字节表示一个字，这种情况下第一个字节肯定是大于等于128。就是说第一个字节最高位是1，这样 <code>(x - 0x01010101L) &amp; 0x80808080L != 0</code>判断是否有<code>\0</code>就失效了，就算上面的判断为true，那4个字节也没有<code>\0</code>，代码会遍历那4个字节，发现实际上没有<code>\0</code>，不退出，继续往后走直到找到<code>\0</code>。</p>

<p>理论上对于ascii字符串，glibc的实现可以达到3X的效率提升，仔细想想 Is it worthwhile?</p>

<p>who knows? ╮(╯_╰)╭, it all depends.</p>

<p>现在的电脑，内存带宽大概在5GB/s(我胡邹的)，<code>mov VAR, %eax</code>这条指令大约消耗十几到几十个时钟周期(这也是胡诌的)。做这样的优化是否有意义不太好说，真是超级无所谓的事情。对程序员来说，就知道大概有这么一种思想，可以这么做，聊以自慰罢了。</p>

<p>&mdash;&mdash;喂喂，你是认真的么</p>

<p>&mdash;&mdash;我错了，我说谎了，最大作用是可以和别人拿来zhuangbility。。。</p>

<p>顺便说一下，CRC32算法也用到这种的思想了(同上)。一次取4字节数据进行计算 + 打表。可以达到原本计算方法几十倍速度的提升吧，大概。。。有兴趣自行wikipedia。</p>

<p>以上</p>

<p>john_smith，2013-12-07，一边听着柿姐的&lt;虎视眈眈>，一边看里番，一边想着中午吃什么，一边写这个。</p>

<p>无所谓，真是超级无所谓的事情。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python断整数相加溢出]]></title>
    <link href="http://lightxue.github.io/python-integer-overflow"/>
    <updated>2013-07-13T22:50:32+08:00</updated>
    <id>http://lightxue.github.io/python-integer-overflow</id>
    <content type="html"><![CDATA[<p>在python解释器的源码里看到一段有趣的代码，它实现了python两个整数相加时如果溢出则用更大的数据类型保存整数。具体代码的如下。</p>

<!--more-->


<p>```c
// python解释器是C语言实现的
static PyObject *
int_add(PyIntObject <em>v, PyIntObject </em>w)
{</p>

<pre><code>register long a, b, x;
CONVERT_TO_LONG(v, a);
CONVERT_TO_LONG(w, b);
/* casts in the line below avoid undefined behaviour on overflow */
x = (long)((unsigned long)a + b); // 重点是这行
if ((x^a) &gt;= 0 || (x^b) &gt;= 0)     // 和这行
    return PyInt_FromLong(x);
return PyLong_Type.tp_as_number-&gt;nb_add((PyObject *)v, (PyObject *)w);
</code></pre>

<p>}
```</p>

<p><code>((x^a) &gt;= 0 || (x^b) &gt;= 0)</code>如果是false，就是发生了溢出。这段代码咋看跟溢出没关系，细看还是挺有名堂的。这个if要判断的是符号位。我们知道，整型的最后一个bit如果是0，那么这个数大于等于0；如果是1，这个数小于0。这个表达式的<code>&gt;= 0</code>判断的就是是否最后一个bit是否是0。</p>

<p>我们知道，^是异或运算：</p>

<p><code>c
0 ^ 0 == 0
0 ^ 1 == 1
1 ^ 0 == 1
1 ^ 1 == 0
</code></p>

<p>简而言之就是两个bit相同得0，两个bit不同得1。也就是说<code>((x^a) &gt;= 0 || (x^b) &gt;= 0)</code>判断的是x与a的符号位相同或x与b的符号位相同。换而言之，x只要跟a和b任意一个数的符号位相同则为true。这跟溢出有什么关系？</p>

<p>我们知道，一个long能表达的数的范围是有限制的，两个long相加的情况不外乎下面6种：</p>

<p>```c
//  没有溢出的情况
非负数 + 非负数 = 非负数
非负数 + 负数 = 负/非负数
负数 + 非负数 = 负/非负数
负数 + 负数 = 负数</p>

<p>// 溢出的情况
非负数 + 非负数 = 负数
负数 + 负数 = 非负数
```</p>

<p>可以看到，没有溢出的情况刚好x和a、b其中一个的符号位相同，而溢出的情况x跟a、b的符号位都不同。所以<code>((x^a) &gt;= 0 || (x^b) &gt;= 0)</code>就刚好能判断出来a+b有没有溢出。</p>

<p>好神奇，我和我的小伙伴们都惊呆了！</p>

<p>有个地方不提一下这个讨论就不完整了。大家可能都注意到代码中的注释了：casts in the line below avoid undefined behaviour on overflow。在<a href="http://en.wikipedia.org/wiki/Integer_overflow">wikipedia</a>上看到的解释是这样的：</p>

<blockquote><p>Since an arithmetic operation may produce a result larger than the maximum representable value, a potential error condition may result. In the C programming language, signed integer overflow causes undefined behavior, while unsigned integer overflow causes the number to be reduced modulo a power of two, meaning that unsigned integers &ldquo;wrap around&rdquo; on overflow.</p></blockquote>

<p>如果是a和b都是signed long，溢出后结果是不确定的，看编译器的实现。如果a或b是unsigned long(相加时另一个也会转成unsigned long)，相加结果再转回long跟上面讨论的6种情况就一样了。</p>

<p>最后留个问题吧，怎么判断两个数相减溢出了呢:&ndash;)</p>

<p>补充：</p>

<p>axu给了我另一种判断整数溢出的判断</p>

<p>```c
t = a + b;
if ((a&lt;0 == b&lt;0) &amp;&amp; (t&lt;0 != a&lt;0))</p>

<pre><code>// overflow
</code></pre>

<p>```</p>

<p>细看其实思路跟上面说的一样，于是弃之不理。望仔看到这段代码后竟然想到去优化这它。</p>

<p>```c
t = a + b;
if (((a<sup>b</sup>) >= 0) &amp;&amp; ((a<sup>t</sup>) &lt; 0))</p>

<pre><code>// overflow
</code></pre>

<p>```</p>

<p>确实比上面的解法有所提升。认真思考的心态值得学习，赞一下望仔。</p>
]]></content>
  </entry>
  
</feed>
